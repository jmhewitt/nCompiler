% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/packaging.R
\name{writePackage}
\alias{writePackage}
\title{Create packages containing compiled elements}
\usage{
writePackage(
  ...,
  package.name,
  dir = ".",
  control = list(),
  modify = get_nOption("modifyPackageContents"),
  roxygen = list(),
  nClass_full_interface = TRUE
)
}
\arguments{
\item{...}{One or more nClass constructor and nFunction objects to be
compiled into the package.}

\item{package.name}{Character string. The name of the package to be written.}

\item{dir}{Character string. Path to the parent directory in which the main
package directory will be created. If not provided, default is the current
working directory.}

\item{control}{A named list of control options or a named list of named lists
of control parameters for each object to be compiled. See Details for more.}

\item{modify}{Logical, default FALSE. Should writing proceed even if the
package exists? If TRUE, elements provided for compilation are added to the
existing package. Existing package elements with the same name as new
elements are overwritten, while elements without name conflicts are
retained. To change the default across multiple calls, use
`set_nOption("modifyPackageContents" = TRUE)`}

\item{roxygen}{A list of roxygen entries corresponding to the objects being
compiled, indicated either by matching names or (if all objects are
documented) by order. The elements of the list are either character strings
or lists produced by documentNClass.}

\item{nClass_full_interface}{}

\item{roxygenize}{Logical, default FALSE. Should roxygen be called to produce
documentation pages before package build?}
}
\description{
Create packages containing compiled elements
}
\details{
`writePackage` is a function for adding compiled nFunctions and nClasses to
an R package. `writePackage` handles compilation, documentation, and
exporting, so that the resulting R package can call the compiled nFunctions
and instantiate members of the nClass without further compilation.

The names of the elements exported in the package will match the internal
names of the elements as they are passed (the \code{name} field in
\code{nFunction} and the \code{classname} field in \code{nClass}), NOT
the names of the objects in the R environment.

If a nonexistent directory or nonexistent directory is indicated by the
arguments \code{dir} and \code{package.name}, writePackage uses Rcpp's
Rcpp.package.skeleton to initialize a directory.

If the directory indicated by those two arguments does exist and
\code{modify} is \code{TRUE}, then the elements passed to `...` are compiled
and added to the package. This process will overwrite existing compiled
objects with overlapping names, so can be used to edit and update package
elements as well as add new elements.

If an uncompilable nFunction or nClass is passed, \code{writePackage} will
not error. This will not be caught until the package is built, for example
with \code{buildPackage}.
}
\examples{
# Initialize an example nFunction
foo <- nFunction(name = "foo",
                 fun = function(x = numericScalar()) {
                     ans <- x+1
                     return(ans)
                     returnType(numericScalar())
                   }
                 )
# Write a package containing the compiled nFunction "foo"
writePackage(foo,
             dir = tempdir(),
             package.name = "fooPackage",
             control = list(export = TRUE))
# Build and install the package
buildPackage("fooPackage", dir = tempdir())
# We can call "foo" from the new namespace
fooPackage::foo(10)
}
\seealso{
For more nCompiler packaging tools, see \code{\link{buildPackage}}
  and \code{\link{erasePackage}}. For nCompiler roxygen utilities see
  \code{\link{documentNClass}} and \code{\link{documentNFunction}}. For
  package initialization tools on which \code{writePackage} depends see
  \code{\link[Rcpp]{Rcpp.package.skeleton}} and
  \code{\link[utils]{package.skeleton}}.
}
